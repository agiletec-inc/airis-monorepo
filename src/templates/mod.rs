use anyhow::{Context, Result};
use handlebars::Handlebars;
use serde_json::json;
use std::collections::HashMap;

use crate::config::WorkspaceConfig;

pub struct TemplateEngine {
    hbs: Handlebars<'static>,
}

impl TemplateEngine {
    pub fn new() -> Result<Self> {
        let mut hbs = Handlebars::new();

        // Register templates (embedded for now, later from files)
        hbs.register_template_string("justfile", JUSTFILE_TEMPLATE)?;
        hbs.register_template_string("package_json", PACKAGE_JSON_TEMPLATE)?;
        hbs.register_template_string("pnpm_workspace", PNPM_WORKSPACE_TEMPLATE)?;
        hbs.register_template_string("docker_compose", DOCKER_COMPOSE_TEMPLATE)?;

        Ok(TemplateEngine { hbs })
    }

    pub fn render_justfile(&self, config: &WorkspaceConfig) -> Result<String> {
        let data = self.prepare_justfile_data(config)?;
        self.hbs
            .render("justfile", &data)
            .context("Failed to render justfile")
    }

    pub fn render_package_json(&self, config: &WorkspaceConfig) -> Result<String> {
        let data = self.prepare_package_json_data(config)?;
        self.hbs
            .render("package_json", &data)
            .context("Failed to render package.json")
    }

    pub fn render_pnpm_workspace(&self, config: &WorkspaceConfig) -> Result<String> {
        let data = self.prepare_pnpm_workspace_data(config)?;
        self.hbs
            .render("pnpm_workspace", &data)
            .context("Failed to render pnpm-workspace.yaml")
    }

    pub fn render_docker_compose(&self, config: &WorkspaceConfig) -> Result<String> {
        let data = self.prepare_docker_compose_data(config)?;
        self.hbs
            .render("docker_compose", &data)
            .context("Failed to render docker-compose.yml")
    }

    fn prepare_justfile_data(&self, config: &WorkspaceConfig) -> Result<serde_json::Value> {
        let apps: Vec<HashMap<String, String>> = config
            .workspaces
            .apps
            .iter()
            .map(|app| {
                let name = WorkspaceConfig::get_app_name(app);
                let app_type = config.get_app_type(app).unwrap_or_else(|| "node".to_string());
                let mut map = HashMap::new();
                map.insert("name".to_string(), name);
                map.insert("type".to_string(), app_type);
                map
            })
            .collect();

        let libs: Vec<HashMap<String, String>> = config
            .workspaces
            .libs
            .iter()
            .map(|lib| {
                let name = WorkspaceConfig::get_lib_name(lib);
                let mut map = HashMap::new();
                map.insert("name".to_string(), name);
                map.insert("type".to_string(), "typescript".to_string());
                map
            })
            .collect();

        Ok(json!({
            "project": config.name,
            "workspace": config.workspace_service(),
            "apps": apps,
            "libs": libs,
        }))
    }

    fn prepare_package_json_data(&self, config: &WorkspaceConfig) -> Result<serde_json::Value> {
        Ok(json!({
            "name": config.name,
            "version": "0.0.0",
            "private": true,
            "catalog": config.catalog,
        }))
    }

    fn prepare_pnpm_workspace_data(&self, config: &WorkspaceConfig) -> Result<serde_json::Value> {
        let mut packages = Vec::new();

        for app in &config.workspaces.apps {
            let name = WorkspaceConfig::get_app_name(app);
            packages.push(format!("apps/{}", name));
        }

        for lib in &config.workspaces.libs {
            let name = WorkspaceConfig::get_lib_name(lib);
            packages.push(format!("libs/{}", name));
        }

        Ok(json!({
            "packages": packages,
            "catalog": config.catalog,
        }))
    }

    fn prepare_docker_compose_data(&self, config: &WorkspaceConfig) -> Result<serde_json::Value> {
        Ok(json!({
            "project": config.name,
            "workspace_service": config.workspace_service(),
            "base_image": config.docker.base_image.clone().unwrap_or_else(|| "node:22-alpine".to_string()),
            "workdir": config.docker.workdir.clone().unwrap_or_else(|| "/app".to_string()),
            "volumes": config.docker.workspace.volumes,
        }))
    }
}

// Embedded templates (will be moved to template files later)

const JUSTFILE_TEMPLATE: &str = r#"# Auto-generated by airis-workspace from workspace.yaml
# DO NOT EDIT - Regenerate with: airis-workspace init --force

project := "{{project}}"
workspace := "{{workspace}}"

# Default recipe (show help)
default:
    @just --list

# ============================================
# Docker Management
# ============================================

# Start all services
up:
    @echo "üöÄ Starting Docker services..."
    docker compose up -d
    @echo "‚úÖ Services started"

# Stop all services
down:
    docker compose down --remove-orphans

# Install dependencies (in Docker)
install:
    @echo "üì¶ Installing dependencies in Docker..."
    docker compose exec {{workspace}} pnpm install
    @echo "‚úÖ Dependencies installed"

# Enter workspace shell
workspace:
    docker compose exec -it {{workspace}} sh

# Show logs
logs:
    docker compose logs -f

# Show container status
ps:
    docker compose ps

# Clean artifacts
clean:
    rm -rf ./node_modules ./dist ./.next ./build ./target
    find . -name ".DS_Store" -delete 2>/dev/null || true

# ============================================
# TypeScript Library Commands
# ============================================

# Dev TypeScript library
dev-ts name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} dev

# Build TypeScript library
build-ts name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} build

# Test TypeScript library
test-ts name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} test

# ============================================
# Next.js Commands
# ============================================

# Dev Next.js app
dev-next name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} dev

# Build Next.js app
build-next name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} build

# Start Next.js production
start-next name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} start

# ============================================
# Node Service Commands
# ============================================

# Dev Node service
dev-node name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} dev

# Build Node service
build-node name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} build

# Start Node service
start-node name:
    docker compose exec {{workspace}} pnpm --filter \{{name}} start

# ============================================
# Rust Commands (Cargo only, no pnpm)
# ============================================

# Build Rust project
build-rust name:
    cargo build --manifest-path \{{name}}/Cargo.toml

# Build Rust release
release-rust name:
    cargo build --release --manifest-path \{{name}}/Cargo.toml

# Run Rust project
run-rust name:
    cargo run --manifest-path \{{name}}/Cargo.toml

# ============================================
# Docker-First Guards (Prevent Host Pollution)
# ============================================

[private]
guard tool:
    @echo "‚ùå ERROR: '\{{tool}}' „ÅØÁõ¥Êé•‰Ωø„Åà„Åæ„Åõ„Çì"
    @echo ""
    @echo "Docker-First„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„Åß„ÅØ„ÄÅ‰ª•‰∏ã„Çí‰Ωø„Å£„Å¶„Åè„Å†„Åï„ÅÑ:"
    @echo "  TypeScript: just dev-ts <name>"
    @echo "  Next.js:    just dev-next <name>"
    @echo "  Node:       just dev-node <name>"
    @echo "  Rust:       just build-rust <name>"
    @echo ""
    @echo "„Åæ„Åü„ÅØ: just workspace ‚Üí pnpm <cmd>"
    @exit 1

pnpm *args:
    @just guard pnpm

npm *args:
    @just guard npm

yarn *args:
    @just guard yarn

# ============================================
# Shortcuts (Project-Specific)
# ============================================
{{#each apps}}

# Dev {{name}} ({{type}})
dev-{{name}}:{{#if (eq type "nextjs")}} (dev-next "{{name}}"){{else if (eq type "node")}} (dev-node "{{name}}"){{else if (eq type "typescript")}} (dev-ts "{{name}}"){{else}} (dev-node "{{name}}"){{/if}}
{{/each}}
"#;

const PACKAGE_JSON_TEMPLATE: &str = r#"{
  "name": "{{name}}",
  "version": "{{version}}",
  "private": {{private}},
  "packageManager": "pnpm@10.12.0",
  "pnpm": {
    "catalog": {
{{#each catalog}}
      "{{@key}}": "{{this}}"{{#unless @last}},{{/unless}}
{{/each}}
    }
  },
  "devDependencies": {
    "typescript": "catalog:",
    "vitest": "catalog:"
  },
  "_generated": {
    "by": "airis-workspace",
    "from": "workspace.yaml",
    "warning": "‚ö†Ô∏è  DO NOT EDIT - Regenerate with 'airis generate'"
  }
}
"#;

const PNPM_WORKSPACE_TEMPLATE: &str = r#"# Auto-generated by airis-workspace
# DO NOT EDIT - Regenerate with: airis-workspace init --force

packages:
{{#each packages}}
  - "{{this}}"
{{/each}}

catalog:
{{#each catalog}}
  {{@key}}: {{this}}
{{/each}}
"#;

const DOCKER_COMPOSE_TEMPLATE: &str = r#"# Auto-generated by airis-workspace from workspace.yaml
# DO NOT EDIT - Regenerate with: airis-workspace init --force

name: {{project}}

services:
  {{workspace_service}}:
    image: {{base_image}}
    working_dir: {{workdir}}
    volumes:
      - ./:{{workdir}}
{{#each volumes}}
      - {{this}}:{{../workdir}}/{{this}}
{{/each}}
    command: sh -c "corepack enable && corepack prepare pnpm@latest --activate && sleep infinity"
    stdin_open: true
    tty: true

volumes:
{{#each volumes}}
  {{this}}:
{{/each}}
"#;
