use std::fs;
use std::io::BufRead;
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use colored::Colorize;

use crate::manifest::{GlobalConfig, Manifest, Mode, MANIFEST_FILE};

/// Additional commands blocked in strict mode
const STRICT_MODE_DENY: &[&str] = &[
    "cargo", "rustc", "python", "python3", "pip", "pip3", "uv",
    "go", "java", "javac", "gradle", "mvn",
];

/// Commands allowed in hybrid mode (local builds)
const HYBRID_MODE_ALLOW: &[&str] = &[
    "cargo", "rustc", "python", "python3", "pip", "pip3", "uv",
];

const GUARDS_DIR: &str = ".airis/bin";

/// Install command guards from manifest.toml
pub fn install() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        anyhow::bail!(
            "manifest.toml not found. Run `airis init` first."
        );
    }

    let manifest = Manifest::load(manifest_path)?;

    // Collect effective deny list based on mode
    let mut effective_deny: Vec<String> = manifest.guards.deny.clone();

    // Apply mode-specific guards
    match &manifest.mode {
        Mode::DockerFirst => {
            // Standard mode: use guards as configured
            println!("{}", "Mode: docker-first (standard guards)".dimmed());
        }
        Mode::Hybrid => {
            // Hybrid mode: allow local toolchains (cargo, python, etc.)
            println!("{}", "Mode: hybrid (allowing local toolchains)".yellow());
            effective_deny.retain(|cmd| !HYBRID_MODE_ALLOW.contains(&cmd.as_str()));
        }
        Mode::Strict => {
            // Strict mode: block additional commands
            println!("{}", "Mode: strict (maximum restrictions)".bright_red());
            for cmd in STRICT_MODE_DENY {
                if !effective_deny.contains(&cmd.to_string()) {
                    effective_deny.push(cmd.to_string());
                }
            }
        }
    }

    if effective_deny.is_empty()
        && manifest.guards.wrap.is_empty()
        && manifest.guards.deny_with_message.is_empty() {
        println!("{}", "‚ö†Ô∏è  No guards to install (all commands allowed in this mode)".yellow());
        return Ok(());
    }

    println!("{}", "üõ°Ô∏è  Installing command guards...".bright_blue());
    println!();

    let guards_dir = PathBuf::from(GUARDS_DIR);
    fs::create_dir_all(&guards_dir)
        .with_context(|| format!("Failed to create {}", GUARDS_DIR))?;

    let mut installed_count = 0;

    // Install deny guards (mode-adjusted)
    for cmd in &effective_deny {
        install_deny_guard(&guards_dir, cmd, None)?;
        installed_count += 1;
        println!("   {} {}", "‚úì".green(), format!("{} (deny)", cmd).dimmed());
    }

    // Install wrap guards
    for (cmd, wrapper) in &manifest.guards.wrap {
        install_wrap_guard(&guards_dir, cmd, wrapper)?;
        installed_count += 1;
        println!("   {} {}", "‚úì".green(), format!("{} ‚Üí {}", cmd, wrapper).dimmed());
    }

    // Install deny with message guards
    for (cmd, message) in &manifest.guards.deny_with_message {
        install_deny_guard(&guards_dir, cmd, Some(message))?;
        installed_count += 1;
        println!("   {} {}", "‚úì".green(), format!("{} (deny with message)", cmd).dimmed());
    }

    println!();
    println!("{}", format!("‚úÖ {} command guards installed", installed_count).green());
    println!();
    println!("{}", "To activate guards:".bright_yellow());
    println!("  export PATH=\"$PWD/{}:$PATH\"", GUARDS_DIR);
    println!();
    println!("{}", "Or use airis shell:".bright_yellow());
    println!("  airis shell");

    Ok(())
}

fn install_deny_guard(guards_dir: &Path, cmd: &str, custom_message: Option<&String>) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let message = if let Some(msg) = custom_message {
        msg.clone()
    } else {
        format!("'{}' is denied by manifest.toml [guards.deny].\n\nUse Docker-first workflow instead:\n  airis shell     # Enter container\n  {}              # Run inside container", cmd, cmd)
    };

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards] section

echo "‚ùå ERROR: {}"
exit 1
"#,
        message.replace("\"", "\\\"")
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn install_wrap_guard(guards_dir: &Path, cmd: &str, wrapper: &str) -> Result<()> {
    let script_path = guards_dir.join(cmd);

    let content = format!(
        r#"#!/usr/bin/env bash
# Auto-generated by airis guards install
# DO NOT EDIT - managed by manifest.toml [guards.wrap] section

# Wrapper: {} ‚Üí {}
exec {} "$@"
"#,
        cmd, wrapper, wrapper
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

fn make_executable(path: &Path) -> Result<()> {
    let mut perms = fs::metadata(path)?.permissions();
    perms.set_mode(0o755); // rwxr-xr-x
    fs::set_permissions(path, perms)?;
    Ok(())
}

/// Check if running inside Docker container (respects mode)
pub fn check_docker() -> Result<()> {
    // Load manifest to check mode
    let manifest_path = Path::new(MANIFEST_FILE);
    let mode = if manifest_path.exists() {
        Manifest::load(manifest_path).map(|m| m.mode).unwrap_or_default()
    } else {
        Mode::default()
    };

    // Hybrid mode allows host execution
    if matches!(mode, Mode::Hybrid) {
        println!("{}", "‚úÖ Hybrid mode: host execution allowed".green());
        return Ok(());
    }

    println!("{}", "üîç Checking Docker environment...".bright_blue());

    // Check DOCKER_CONTAINER environment variable
    if std::env::var("DOCKER_CONTAINER").unwrap_or_default() == "true" {
        println!("{}", "‚úÖ Running inside Docker container (DOCKER_CONTAINER=true)".green());
        return Ok(());
    }

    // Check for /.dockerenv file
    if Path::new("/.dockerenv").exists() {
        println!("{}", "‚úÖ Running inside Docker container (/.dockerenv exists)".green());
        return Ok(());
    }

    // Check /proc/1/cgroup for Docker
    if let Ok(content) = fs::read_to_string("/proc/1/cgroup")
        && (content.contains("docker") || content.contains("containerd")) {
            println!("{}", "‚úÖ Running inside Docker container (cgroup detected)".green());
            return Ok(());
        }

    // Check for CI environment
    if std::env::var("CI").unwrap_or_default() == "true"
        || std::env::var("GITHUB_ACTIONS").unwrap_or_default() == "true"
        || std::env::var("GITLAB_CI").unwrap_or_default() == "true"
    {
        println!("{}", "‚úÖ Running in CI environment".green());
        return Ok(());
    }

    // Not in Docker - show error
    println!();
    println!("{}", "=".repeat(70).red());
    println!("{}", "‚ùå CRITICAL ERROR: Not running inside Docker container".red().bold());
    println!("{}", "=".repeat(70).red());
    println!();
    println!("{}", "„ÄêÂïèÈ°å„Äë".bright_yellow());
    println!("  Mac „Éõ„Çπ„Éà‰∏ä„ÅßÂÆüË°å„Åó„Çà„ÅÜ„Å®„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇ");
    println!("  Docker-FirstÈñãÁô∫„Åß„ÅØ„ÄÅÂÖ®„Å¶„ÅÆ„Ç≥„Éû„É≥„Éâ„ÅØDockerÂÜÖ„ÅßÂÆüË°å„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ");
    println!();
    println!("{}", "„ÄêÊ≠£„Åó„ÅÑ‰ΩøÁî®ÊñπÊ≥ï„Äë".bright_yellow());
    println!("  1. {} # Docker „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„Çπ„Å´ÂÖ•„Çã", "airis shell".cyan());
    println!("  2. „Ç≥„Éû„É≥„Éâ„ÇíÂÆüË°å");
    println!();
    println!("{}", "„Äê„Åæ„Åü„ÅØ„Äë".bright_yellow());
    println!("  {} # „Ç≥„É≥„ÉÜ„ÉäÂÜÖ„ÅßÁõ¥Êé•ÂÆüË°å", "airis exec workspace <command>".cyan());
    println!();
    println!("{}", "„Äê„Éí„É≥„Éà„Äë".bright_yellow());
    println!("  „Éõ„Çπ„Éà„Åß„ÅÆÂÆüË°å„ÇíË®±ÂèØ„Åô„Çã„Å´„ÅØ„ÄÅmanifest.toml „Åß mode = \"hybrid\" „ÇíË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
    println!();
    println!("{}", "=".repeat(70).red());

    anyhow::bail!("Not running inside Docker container");
}

/// Show guard status
pub fn status() -> Result<()> {
    let manifest_path = Path::new(MANIFEST_FILE);

    if !manifest_path.exists() {
        println!("{}", "‚ö†Ô∏è  manifest.toml not found".yellow());
        return Ok(());
    }

    let manifest = Manifest::load(manifest_path)?;
    let guards_dir = PathBuf::from(GUARDS_DIR);

    println!("{}", "üõ°Ô∏è  Guard Status".bright_blue());
    println!();

    // Check if guards directory exists
    if !guards_dir.exists() {
        println!("{}", "Guards not installed. Run: airis guards install".yellow());
        return Ok(());
    }

    // Show deny guards
    if !manifest.guards.deny.is_empty() {
        println!("{}", "Deny guards:".bright_yellow());
        for cmd in &manifest.guards.deny {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "‚úì".green() } else { "‚úó".red() };
            println!("  {} {}", status, cmd);
        }
        println!();
    }

    // Show wrap guards
    if !manifest.guards.wrap.is_empty() {
        println!("{}", "Wrap guards:".bright_yellow());
        for (cmd, wrapper) in &manifest.guards.wrap {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "‚úì".green() } else { "‚úó".red() };
            println!("  {} {} ‚Üí {}", status, cmd, wrapper.dimmed());
        }
        println!();
    }

    // Show deny with message
    if !manifest.guards.deny_with_message.is_empty() {
        println!("{}", "Deny with message:".bright_yellow());
        for (cmd, _) in &manifest.guards.deny_with_message {
            let guard_path = guards_dir.join(cmd);
            let status = if guard_path.exists() { "‚úì".green() } else { "‚úó".red() };
            println!("  {} {}", status, cmd);
        }
    }

    Ok(())
}

/// Uninstall local guards
pub fn uninstall() -> Result<()> {
    let guards_dir = PathBuf::from(GUARDS_DIR);

    if !guards_dir.exists() {
        println!("{}", "‚ö†Ô∏è  Guards not installed (no .airis/bin directory)".yellow());
        return Ok(());
    }

    println!("{}", "üóëÔ∏è  Uninstalling local guards...".bright_blue());
    println!();

    let mut removed_count = 0;

    // Remove only files that have the airis guard marker
    for entry in fs::read_dir(&guards_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() && is_airis_guard(&path)? {
            let name = path.file_name().unwrap_or_default().to_string_lossy();
            fs::remove_file(&path)?;
            println!("   {} {}", "‚úì".green(), format!("Removed {}", name).dimmed());
            removed_count += 1;
        }
    }

    // Remove directory if empty
    if guards_dir.read_dir()?.next().is_none() {
        fs::remove_dir(&guards_dir)?;
        println!("   {} {}", "‚úì".green(), "Removed .airis/bin directory".dimmed());
    }

    println!();
    println!("{}", format!("‚úÖ {} guard(s) uninstalled", removed_count).green());

    Ok(())
}

// =============================================================================
// Global Guards (~/.airis/bin)
// =============================================================================

const GLOBAL_GUARD_MARKER: &str = "Auto-generated by airis guards --global install";

/// Install global guards to ~/.airis/bin
pub fn install_global() -> Result<()> {
    println!("{}", "üåç Installing global guards...".bright_blue());
    println!();

    // Load or create global config
    let config = GlobalConfig::load()?;
    let config_path = GlobalConfig::config_path()?;
    let bin_dir = GlobalConfig::bin_dir()?;

    // Create directories
    fs::create_dir_all(&bin_dir)
        .with_context(|| format!("Failed to create {:?}", bin_dir))?;

    // Save default config if it doesn't exist
    if !config_path.exists() {
        config.save()?;
        println!("   {} {}", "‚úì".green(), format!("Created {}", config_path.display()).dimmed());
    }

    let mut installed_count = 0;

    // Install guard scripts for each denied command
    for cmd in &config.guards.deny {
        install_global_guard(&bin_dir, cmd)?;
        installed_count += 1;
        println!("   {} {}", "‚úì".green(), format!("{} (global guard)", cmd).dimmed());
    }

    println!();
    println!("{}", format!("‚úÖ {} global guard(s) installed", installed_count).green());
    println!();
    println!("{}", "üìÅ Config:".bright_yellow());
    println!("   {}", config_path.display());
    println!();
    println!("{}", "üîß To activate, add to your shell profile (~/.zshrc or ~/.bashrc):".bright_yellow());
    println!();
    println!("   {}", "export PATH=\"$HOME/.airis/bin:$PATH\"".cyan());
    println!();
    println!("{}", "Then reload your shell or run:".dimmed());
    println!("   {}", "source ~/.zshrc".dimmed());

    Ok(())
}

fn install_global_guard(bin_dir: &Path, cmd: &str) -> Result<()> {
    let script_path = bin_dir.join(cmd);

    // Global guard script that:
    // 1. Searches upward for manifest.toml
    // 2. If found: execute the real command (allow)
    // 3. If not found: block with error message
    let content = format!(
        r#"#!/usr/bin/env bash
# {GLOBAL_GUARD_MARKER}
# DO NOT EDIT - managed by airis global guards

# Find manifest.toml by walking up directories
find_manifest() {{
    local dir="$PWD"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/manifest.toml" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}}

# Check if we're in an airis project
if find_manifest > /dev/null 2>&1; then
    # Inside airis project: find and execute the real command
    # Remove ~/.airis/bin from PATH to find the real command
    REAL_CMD=$(PATH=$(echo "$PATH" | tr ':' '\n' | grep -v '\.airis/bin' | tr '\n' ':' | sed 's/:$//') which {cmd} 2>/dev/null)
    if [[ -n "$REAL_CMD" && -x "$REAL_CMD" ]]; then
        exec "$REAL_CMD" "$@"
    else
        echo "‚ùå ERROR: '{cmd}' not found in PATH (excluding ~/.airis/bin)"
        exit 127
    fi
fi

# Outside airis project: block
echo "‚ùå ERROR: '{cmd}' is blocked outside of airis projects."
echo ""
echo "You are not in a directory with manifest.toml."
echo ""
echo "Either:"
echo "  1. Navigate to an airis project directory first"
echo "  2. Or use 'airis shell' to enter a Docker container"
echo ""
echo "To manage global guards:"
echo "  airis guards --global status     # Check status"
echo "  airis guards --global uninstall  # Remove guards"
exit 1
"#,
        GLOBAL_GUARD_MARKER = GLOBAL_GUARD_MARKER,
        cmd = cmd
    );

    fs::write(&script_path, content)
        .with_context(|| format!("Failed to write global guard script for '{}'", cmd))?;

    make_executable(&script_path)?;

    Ok(())
}

/// Show global guards status
pub fn status_global() -> Result<()> {
    let config_path = GlobalConfig::config_path()?;
    let bin_dir = GlobalConfig::bin_dir()?;

    println!("{}", "üåç Global Guard Status".bright_blue());
    println!();

    // Check config file
    println!("{}", "Config file:".bright_yellow());
    if config_path.exists() {
        println!("   {} {}", "‚úì".green(), config_path.display());
    } else {
        println!("   {} {} (will use defaults)", "‚úó".yellow(), config_path.display());
    }
    println!();

    // Check bin directory
    println!("{}", "Guard directory:".bright_yellow());
    if bin_dir.exists() {
        println!("   {} {}", "‚úì".green(), bin_dir.display());
    } else {
        println!("   {} {} (not created)", "‚úó".yellow(), bin_dir.display());
        println!();
        println!("{}", "Run 'airis guards --global install' to install guards".yellow());
        return Ok(());
    }
    println!();

    // Load config and show guards
    let config = GlobalConfig::load()?;

    println!("{}", "Installed guards:".bright_yellow());
    for cmd in &config.guards.deny {
        let guard_path = bin_dir.join(cmd);
        let status = if guard_path.exists() && is_global_guard(&guard_path)? {
            "‚úì".green()
        } else if guard_path.exists() {
            "?".yellow() // File exists but not our guard
        } else {
            "‚úó".red()
        };
        println!("   {} {}", status, cmd);
    }
    println!();

    // Check PATH
    println!("{}", "PATH check:".bright_yellow());
    let path_var = std::env::var("PATH").unwrap_or_default();
    let bin_dir_str = bin_dir.to_string_lossy();
    if path_var.contains(&*bin_dir_str) {
        println!("   {} ~/.airis/bin is in PATH", "‚úì".green());
    } else {
        println!("   {} ~/.airis/bin is NOT in PATH", "‚úó".red());
        println!();
        println!("{}", "Add to your ~/.zshrc or ~/.bashrc:".bright_yellow());
        println!("   {}", "export PATH=\"$HOME/.airis/bin:$PATH\"".cyan());
    }

    Ok(())
}

/// Uninstall global guards
pub fn uninstall_global() -> Result<()> {
    let bin_dir = GlobalConfig::bin_dir()?;

    if !bin_dir.exists() {
        println!("{}", "‚ö†Ô∏è  Global guards not installed (no ~/.airis/bin directory)".yellow());
        return Ok(());
    }

    println!("{}", "üóëÔ∏è  Uninstalling global guards...".bright_blue());
    println!();

    let mut removed_count = 0;

    // Remove only files that have the global guard marker
    for entry in fs::read_dir(&bin_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() && is_global_guard(&path)? {
            let name = path.file_name().unwrap_or_default().to_string_lossy();
            fs::remove_file(&path)?;
            println!("   {} {}", "‚úì".green(), format!("Removed {}", name).dimmed());
            removed_count += 1;
        }
    }

    // Remove directory if empty
    if bin_dir.read_dir()?.next().is_none() {
        fs::remove_dir(&bin_dir)?;
        println!("   {} {}", "‚úì".green(), "Removed ~/.airis/bin directory".dimmed());
    }

    println!();
    println!("{}", format!("‚úÖ {} global guard(s) uninstalled", removed_count).green());

    Ok(())
}

/// Check if a file is an airis local guard (contains our marker)
fn is_airis_guard(path: &Path) -> Result<bool> {
    let file = fs::File::open(path)?;
    let reader = std::io::BufReader::new(file);

    // Check first 5 lines for the marker
    for line in reader.lines().take(5) {
        if let Ok(line) = line {
            if line.contains("Auto-generated by airis guards install") {
                return Ok(true);
            }
        }
    }

    Ok(false)
}

/// Check if a file is an airis global guard (contains our marker)
fn is_global_guard(path: &Path) -> Result<bool> {
    let file = fs::File::open(path)?;
    let reader = std::io::BufReader::new(file);

    // Check first 5 lines for the marker
    for line in reader.lines().take(5) {
        if let Ok(line) = line {
            if line.contains(GLOBAL_GUARD_MARKER) {
                return Ok(true);
            }
        }
    }

    Ok(false)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_strict_mode_deny_list() {
        // Strict mode should block cargo, python, etc.
        assert!(STRICT_MODE_DENY.contains(&"cargo"));
        assert!(STRICT_MODE_DENY.contains(&"python"));
        assert!(STRICT_MODE_DENY.contains(&"go"));
    }

    #[test]
    fn test_hybrid_mode_allow_list() {
        // Hybrid mode should allow cargo, python, etc.
        assert!(HYBRID_MODE_ALLOW.contains(&"cargo"));
        assert!(HYBRID_MODE_ALLOW.contains(&"python"));
    }

    #[test]
    fn test_hybrid_mode_filters_deny_list() {
        // Simulate hybrid mode filtering
        let deny_list = vec![
            "npm".to_string(),
            "yarn".to_string(),
            "cargo".to_string(),
            "python".to_string(),
        ];

        let filtered: Vec<String> = deny_list
            .into_iter()
            .filter(|cmd| !HYBRID_MODE_ALLOW.contains(&cmd.as_str()))
            .collect();

        // npm and yarn should remain denied
        assert!(filtered.contains(&"npm".to_string()));
        assert!(filtered.contains(&"yarn".to_string()));
        // cargo and python should be allowed
        assert!(!filtered.contains(&"cargo".to_string()));
        assert!(!filtered.contains(&"python".to_string()));
    }

    #[test]
    fn test_strict_mode_adds_to_deny_list() {
        // Simulate strict mode adding commands
        let mut deny_list: Vec<String> = vec!["npm".to_string(), "yarn".to_string()];

        for cmd in STRICT_MODE_DENY {
            if !deny_list.contains(&cmd.to_string()) {
                deny_list.push(cmd.to_string());
            }
        }

        // Should now contain both original and strict mode commands
        assert!(deny_list.contains(&"npm".to_string()));
        assert!(deny_list.contains(&"cargo".to_string()));
        assert!(deny_list.contains(&"python".to_string()));
    }

    #[test]
    fn test_global_config_default() {
        let config = GlobalConfig::default();
        assert_eq!(config.version, 1);
        assert!(config.guards.deny.contains(&"npm".to_string()));
        assert!(config.guards.deny.contains(&"yarn".to_string()));
        assert!(config.guards.deny.contains(&"pnpm".to_string()));
        assert!(config.guards.deny.contains(&"bun".to_string()));
        assert!(config.guards.deny.contains(&"npx".to_string()));
    }

    #[test]
    fn test_global_config_paths() {
        // Just verify that path functions don't panic
        let config_path = GlobalConfig::config_path();
        assert!(config_path.is_ok());

        let bin_dir = GlobalConfig::bin_dir();
        assert!(bin_dir.is_ok());

        // Verify paths contain expected components
        let config_path = config_path.unwrap();
        assert!(config_path.to_string_lossy().contains(".airis"));
        assert!(config_path.to_string_lossy().contains("global-config.toml"));

        let bin_dir = bin_dir.unwrap();
        assert!(bin_dir.to_string_lossy().contains(".airis"));
        assert!(bin_dir.to_string_lossy().ends_with("bin"));
    }

    #[test]
    fn test_global_config_serialization() {
        let config = GlobalConfig::default();
        let toml_str = toml::to_string_pretty(&config).unwrap();

        // Verify it can be deserialized back
        let parsed: GlobalConfig = toml::from_str(&toml_str).unwrap();
        assert_eq!(parsed.version, config.version);
        assert_eq!(parsed.guards.deny.len(), config.guards.deny.len());
    }

    #[test]
    fn test_is_airis_guard_marker() {
        use std::io::Write;

        let dir = tempfile::tempdir().unwrap();
        let guard_file = dir.path().join("npm");

        // Write a file with the guard marker
        let mut f = fs::File::create(&guard_file).unwrap();
        writeln!(f, "#!/usr/bin/env bash").unwrap();
        writeln!(f, "# Auto-generated by airis guards install").unwrap();
        writeln!(f, "echo 'blocked'").unwrap();

        assert!(is_airis_guard(&guard_file).unwrap());

        // Write a file without the marker
        let other_file = dir.path().join("other");
        let mut f = fs::File::create(&other_file).unwrap();
        writeln!(f, "#!/usr/bin/env bash").unwrap();
        writeln!(f, "echo 'hello'").unwrap();

        assert!(!is_airis_guard(&other_file).unwrap());
    }

    #[test]
    fn test_is_global_guard_marker() {
        use std::io::Write;

        let dir = tempfile::tempdir().unwrap();
        let guard_file = dir.path().join("npm");

        // Write a file with the global guard marker
        let mut f = fs::File::create(&guard_file).unwrap();
        writeln!(f, "#!/usr/bin/env bash").unwrap();
        writeln!(f, "# {}", GLOBAL_GUARD_MARKER).unwrap();
        writeln!(f, "echo 'blocked'").unwrap();

        assert!(is_global_guard(&guard_file).unwrap());

        // Write a file with the local guard marker (should not match)
        let local_file = dir.path().join("local");
        let mut f = fs::File::create(&local_file).unwrap();
        writeln!(f, "#!/usr/bin/env bash").unwrap();
        writeln!(f, "# Auto-generated by airis guards install").unwrap();
        writeln!(f, "echo 'blocked'").unwrap();

        assert!(!is_global_guard(&local_file).unwrap());
    }
}
